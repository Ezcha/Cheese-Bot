'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var EventEmitter = require('events').EventEmitter;
var debug = require('./debug');
var compression = require('./transforms/compression');
var framing = require('./transforms/framing');
var crypto = require('crypto');
var states = require("./states");

var createSerializer = require("./transforms/serializer").createSerializer;
var createDeserializer = require("./transforms/serializer").createDeserializer;

var Client = (function (_EventEmitter) {
  _inherits(Client, _EventEmitter);

  function Client(isServer, version) {
    _classCallCheck(this, Client);

    _get(Object.getPrototypeOf(Client.prototype), 'constructor', this).call(this);
    this.packetsToParse = {};
    this.compressor = null;
    this.framer = framing.createFramer();
    this.cipher = null;
    this.decipher = null;
    this.splitter = framing.createSplitter();
    this.decompressor = null;
    this.protocolState = states.HANDSHAKING;
    this.version = version;
    this.isServer = !!isServer;
    this.setSerializer(states.HANDSHAKING);

    this.on('newListener', function (event, listener) {
      var direction = this.isServer ? 'toServer' : 'toClient';
      if (typeof this.packetsToParse[event] === "undefined") this.packetsToParse[event] = 1;else this.packetsToParse[event] += 1;
    });
    this.on('removeListener', function (event, listener) {
      var direction = this.isServer ? 'toServer' : 'toClient';
      this.packetsToParse[event] -= 1;
    });
  }

  _createClass(Client, [{
    key: 'setSerializer',
    value: function setSerializer(state) {
      var _this = this;

      this.serializer = createSerializer({ isServer: this.isServer, version: this.version, state: state });
      this.deserializer = createDeserializer({ isServer: this.isServer, version: this.version, state: state, packetsToParse: this.packetsToParse });

      this.serializer.on('error', function (e) {
        var parts = e.field.split(".");
        parts.shift();
        var serializerDirection = !_this.isServer ? 'toServer' : 'toClient';
        e.field = [_this.protocolState, serializerDirection].concat(parts).join(".");
        e.message = 'Serialization error for ' + e.field + ' : ' + e.message;
        _this.emit('error', e);
      });

      this.deserializer.on('error', function (e) {
        var parts = e.field.split(".");
        parts.shift();
        var deserializerDirection = _this.isServer ? 'toServer' : 'toClient';
        e.field = [_this.protocolState, deserializerDirection].concat(parts).join(".");
        e.message = 'Deserialization error for ' + e.field + ' : ' + e.message;
        _this.emit('error', e);
      });

      this.deserializer.on('data', function (parsed) {
        parsed.metadata.name = parsed.data.name;
        parsed.data = parsed.data.params;
        parsed.metadata.state = state;
        _this.emit('packet', parsed.data, parsed.metadata);
        _this.emit(parsed.metadata.name, parsed.data, parsed.metadata);
        _this.emit('raw.' + parsed.metadata.name, parsed.buffer, parsed.metadata);
        _this.emit('raw', parsed.buffer, parsed.metadata);
      });
    }
  }, {
    key: 'setSocket',
    value: function setSocket(socket) {
      var _this2 = this;

      var ended = false;

      // TODO : A lot of other things needs to be done.
      var endSocket = function endSocket() {
        if (ended) return;
        ended = true;
        _this2.socket.removeListener('close', endSocket);
        _this2.socket.removeListener('end', endSocket);
        _this2.socket.removeListener('timeout', endSocket);
        _this2.emit('end', _this2._endReason);
      };

      var onFatalError = function onFatalError(err) {
        _this2.emit('error', err);
        endSocket();
      };

      var onError = function onError(err) {
        return _this2.emit('error', err);
      };

      this.socket = socket;

      if (this.socket.setNoDelay) this.socket.setNoDelay(true);

      this.socket.on('connect', function () {
        return _this2.emit('connect');
      });

      this.socket.on('error', onFatalError);
      this.socket.on('close', endSocket);
      this.socket.on('end', endSocket);
      this.socket.on('timeout', endSocket);
      this.framer.on('error', onError);
      this.splitter.on('error', onError);

      this.socket.pipe(this.splitter).pipe(this.deserializer);
      this.serializer.pipe(this.framer).pipe(this.socket);
    }
  }, {
    key: 'end',
    value: function end(reason) {
      this._endReason = reason;
      if (this.socket) this.socket.end();
    }
  }, {
    key: 'setEncryption',
    value: function setEncryption(sharedSecret) {
      var _this3 = this;

      if (this.cipher != null) throw new Error("Set encryption twice !");
      this.cipher = crypto.createCipheriv('aes-128-cfb8', sharedSecret, sharedSecret);
      this.cipher.on('error', function (err) {
        return _this3.emit('error', err);
      });
      this.framer.unpipe(this.socket);
      this.framer.pipe(this.cipher).pipe(this.socket);
      this.decipher = crypto.createDecipheriv('aes-128-cfb8', sharedSecret, sharedSecret);
      this.decipher.on('error', function (err) {
        return _this3.emit('error', err);
      });
      this.socket.unpipe(this.splitter);
      this.socket.pipe(this.decipher).pipe(this.splitter);
    }
  }, {
    key: 'setCompressionThreshold',
    value: function setCompressionThreshold(threshold) {
      var _this4 = this;

      if (this.compressor == null) {
        this.compressor = compression.createCompressor(threshold);
        this.compressor.on('error', function (err) {
          return _this4.emit('error', err);
        });
        this.serializer.unpipe(this.framer);
        this.serializer.pipe(this.compressor).pipe(this.framer);
        this.decompressor = compression.createDecompressor(threshold);
        this.decompressor.on('error', function (err) {
          return _this4.emit('error', err);
        });
        this.splitter.unpipe(this.deserializer);
        this.splitter.pipe(this.decompressor).pipe(this.deserializer);
      } else {
        this.decompressor.threshold = threshold;
        this.compressor.threshold = threshold;
      }
    }
  }, {
    key: 'write',
    value: function write(name, params) {
      debug("writing packet " + this.state + "." + name);
      debug(params);
      this.serializer.write({ name: name, params: params });
    }
  }, {
    key: 'writeRaw',
    value: function writeRaw(buffer) {
      if (this.compressor === null) this.framer.write(buffer);else this.compressor.write(buffer);
    }
  }, {
    key: 'state',
    get: function get() {
      return this.protocolState;
    },
    set: function set(newProperty) {
      var oldProperty = this.protocolState;
      this.protocolState = newProperty;

      if (!this.compressor) {
        this.serializer.unpipe(this.framer);
        this.splitter.unpipe(this.deserializer);
      } else {
        this.serializer.unpipe(this.compressor);
        this.decompressor.unpipe(this.deserializer);
      }

      this.serializer.removeAllListeners();
      this.deserializer.removeAllListeners();
      this.setSerializer(this.protocolState);

      if (!this.compressor) {
        this.serializer.pipe(this.framer);
        this.splitter.pipe(this.deserializer);
      } else {
        this.serializer.pipe(this.compressor);
        this.decompressor.pipe(this.deserializer);
      }

      this.emit('state', newProperty, oldProperty);
    }
  }, {
    key: 'compressionThreshold',
    get: function get() {
      return this.compressor == null ? -2 : this.compressor.compressionThreshold;
    },
    set: function set(threshold) {
      this.setCompressionThreshold(threshold);
    }
  }]);

  return Client;
})(EventEmitter);

module.exports = Client;
//# sourceMappingURL=maps/client.js.map
