{"version":3,"sources":["datatypes/numeric.js"],"names":[],"mappings":";;;;AAAA,SAAS,QAAQ,CAAC,MAAM,EAAE,MAAM,EAAE;AAChC,MAAG,MAAM,GAAG,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,OAAO,IAAI,CAAC;AAC3C,SAAO;AACL,SAAK,EAAE,CAAC,MAAM,CAAC,WAAW,CAAC,MAAM,CAAC,EAAE,MAAM,CAAC,WAAW,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;AACnE,QAAI,EAAE,CAAC;GACR,CAAC;CACH;;AAED,SAAS,SAAS,CAAC,KAAK,EAAE,MAAM,EAAE,MAAM,EAAE;AACxC,QAAM,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,MAAM,CAAC,CAAC;AACtC,QAAM,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,MAAM,GAAG,CAAC,CAAC,CAAC;AAC1C,SAAO,MAAM,GAAG,CAAC,CAAC;CACnB;;AAED,SAAS,iBAAiB,CAAC,YAAY,EAAC,YAAY,EAAC,IAAI,EACzD;AACE,MAAI,MAAM,GAAC,SAAP,MAAM,CAAU,MAAM,EAAE,MAAM,EAClC;AACE,QAAG,MAAM,GAAG,IAAI,GAAG,MAAM,CAAC,MAAM,EAAE,OAAO,IAAI,CAAC;AAC9C,QAAI,KAAK,GAAG,MAAM,CAAC,YAAY,CAAC,CAAC,MAAM,CAAC,CAAC;AACzC,WAAO;AACL,WAAK,EAAE,KAAK;AACZ,UAAI,EAAE,IAAI;KACX,CAAC;GACH,CAAC;AACF,MAAI,MAAM,GAAC,SAAP,MAAM,CAAU,KAAK,EAAE,MAAM,EAAE,MAAM,EAAE;AACzC,UAAM,CAAC,YAAY,CAAC,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;AACpC,WAAO,MAAM,GAAG,IAAI,CAAC;GACtB,CAAC;AACF,SAAO,CAAC,MAAM,EAAE,MAAM,EAAE,IAAI,CAAC,CAAC;CAC/B;;AAED,IAAI,IAAI,GAAE;AACR,QAAM,EAAE,CAAC,UAAU,EAAE,WAAW,EAAE,CAAC,CAAC;AACpC,SAAO,EAAE,CAAC,WAAW,EAAE,YAAY,EAAE,CAAC,CAAC;AACvC,SAAO,EAAE,CAAC,aAAa,EAAE,cAAc,EAAE,CAAC,CAAC;AAC3C,UAAQ,EAAE,CAAC,cAAc,EAAE,eAAe,EAAE,CAAC,CAAC;AAC9C,OAAK,EAAE,CAAC,aAAa,EAAE,cAAc,EAAE,CAAC,CAAC;AACzC,SAAO,EAAE,CAAC,aAAa,EAAE,cAAc,EAAE,CAAC,CAAC;AAC3C,UAAQ,EAAE,CAAC,cAAc,EAAE,eAAe,EAAE,CAAC,CAAC;CAC/C,CAAC;;AAEF,IAAI,KAAK,GAAC,aAAY,IAAI,CAAC,CAAC,MAAM,CAAC,UAAS,KAAK,EAAC,GAAG,EAAC;AACpD,OAAK,CAAC,GAAG,CAAC,GAAC,iBAAiB,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACvE,SAAO,KAAK,CAAC;CACd,EAAC,EAAE,CAAC,CAAC;AACN,KAAK,CAAC,MAAM,CAAC,GAAC,CAAC,QAAQ,EAAE,SAAS,EAAE,CAAC,CAAC,CAAC;;AAGvC,MAAM,CAAC,OAAO,GAAG,KAAK,CAAC","file":"datatypes/numeric.js","sourcesContent":["function readLong(buffer, offset) {\n  if(offset + 8 > buffer.length) return null;\n  return {\n    value: [buffer.readInt32BE(offset), buffer.readInt32BE(offset + 4)],\n    size: 8,\n  };\n}\n\nfunction writeLong(value, buffer, offset) {\n  buffer.writeInt32BE(value[0], offset);\n  buffer.writeInt32BE(value[1], offset + 4);\n  return offset + 8;\n}\n\nfunction generateFunctions(bufferReader,bufferWriter,size)\n{\n  var reader=function(buffer, offset)\n  {\n    if(offset + size > buffer.length) return null;\n    var value = buffer[bufferReader](offset);\n    return {\n      value: value,\n      size: size\n    };\n  };\n  var writer=function(value, buffer, offset) {\n    buffer[bufferWriter](value, offset);\n    return offset + size;\n  };\n  return [reader, writer, size];\n}\n\nvar nums= {\n  'byte': [\"readInt8\", \"writeInt8\", 1],\n  'ubyte': [\"readUInt8\", \"writeUInt8\", 1],\n  'short': [\"readInt16BE\", \"writeInt16BE\", 2],\n  'ushort': [\"readUInt16BE\", \"writeUInt16BE\", 2],\n  'int': [\"readInt32BE\", \"writeInt32BE\", 4],\n  'float': [\"readFloatBE\", \"writeFloatBE\", 4],\n  'double': [\"readDoubleBE\", \"writeDoubleBE\", 8]\n};\n\nvar types=Object.keys(nums).reduce(function(types,num){\n  types[num]=generateFunctions(nums[num][0], nums[num][1], nums[num][2]);\n  return types;\n},{});\ntypes[\"long\"]=[readLong, writeLong, 8];\n\n\nmodule.exports = types;\n"],"sourceRoot":"/source/"}