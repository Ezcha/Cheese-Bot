'use strict';

var _Object$keys = require('babel-runtime/core-js/object/keys')['default'];

var _require = require("../utils");

var getField = _require.getField;
var tryCatch = _require.tryCatch;
var addErrorField = _require.addErrorField;

module.exports = {
  'array': [readArray, writeArray, sizeOfArray],
  'count': [readCount, writeCount, sizeOfCount],
  'container': [readContainer, writeContainer, sizeOfContainer]
};

function evalCount(count, fields) {
  if (fields[count["field"]] in count["map"]) return count["map"][fields[count["field"]]];
  return count["default"];
}

function readArray(buffer, offset, typeArgs, rootNode) {
  var _this = this;

  var results = {
    value: [],
    size: 0
  };
  var count;
  if (typeof typeArgs.count === "object") count = evalCount(typeArgs.count, rootNode);else if (typeof typeArgs.count !== "undefined") count = getField(typeArgs.count, rootNode);else if (typeof typeArgs.countType !== "undefined") {
    var countResults;
    tryCatch(function () {
      countResults = _this.read(buffer, offset, { type: typeArgs.countType, typeArgs: typeArgs.countTypeArgs }, rootNode);
    }, function (e) {
      addErrorField(e, "$count");
      throw e;
    });
    results.size += countResults.size;
    offset += countResults.size;
    count = countResults.value;
  } else // TODO : broken schema, should probably error out.
    count = 0;
  for (var i = 0; i < count; i++) {
    var readResults;
    tryCatch(function () {
      readResults = _this.read(buffer, offset, typeArgs.type, rootNode);
    }, function (e) {
      addErrorField(e, i);
      throw e;
    });
    results.size += readResults.size;
    offset += readResults.size;
    results.value.push(readResults.value);
  }
  return results;
}

function writeArray(value, buffer, offset, typeArgs, rootNode) {
  var _this2 = this;

  if (typeof typeArgs.count === "undefined" && typeof typeArgs.countType !== "undefined") {
    tryCatch(function () {
      offset = _this2.write(value.length, buffer, offset, { type: typeArgs.countType, typeArgs: typeArgs.countTypeArgs }, rootNode);
    }, function (e) {
      addErrorField(e, "$count");
      throw e;
    });
  } else if (typeof typeArgs.count === "undefined") {// Broken schema, should probably error out
  }
  for (var index in value) {
    tryCatch(function () {
      offset = _this2.write(value[index], buffer, offset, typeArgs.type, rootNode);
    }, function (e) {
      addErrorField(e, index);
      throw e;
    });
  }
  return offset;
}

function sizeOfArray(value, typeArgs, rootNode) {
  var _this3 = this;

  var size = 0;
  if (typeof typeArgs.count === "undefined" && typeof typeArgs.countType !== "undefined") {
    tryCatch(function () {
      size = _this3.sizeOf(value.length, { type: typeArgs.countType, typeArgs: typeArgs.countTypeArgs }, rootNode);
    }, function (e) {
      addErrorField(e, "$count");
      throw e;
    });
  }
  for (var index in value) {
    tryCatch(function () {
      size += _this3.sizeOf(value[index], typeArgs.type, rootNode);
    }, function (e) {
      addErrorField(e, index);
      throw e;
    });
  }
  return size;
}

function readContainer(buffer, offset, typeArgs, context) {
  var _this4 = this;

  var results = {
    value: { "..": context },
    size: 0
  };
  typeArgs.forEach(function (typeArg) {
    tryCatch(function () {
      var readResults = _this4.read(buffer, offset, typeArg.type, results.value);
      results.size += readResults.size;
      offset += readResults.size;
      if (typeArg.anon) {
        if (readResults.value !== undefined) _Object$keys(readResults.value).forEach(function (key) {
          results.value[key] = readResults.value[key];
        });
      } else results.value[typeArg.name] = readResults.value;
    }, function (e) {
      if (typeArgs && typeArg && typeArg.name) addErrorField(e, typeArg.name);else addErrorField(e, "unknown");
      throw e;
    });
  });
  delete results.value[".."];
  return results;
}

function writeContainer(value, buffer, offset, typeArgs, context) {
  var _this5 = this;

  value[".."] = context;
  typeArgs.forEach(function (typeArg) {
    tryCatch(function () {
      if (typeArg.anon) offset = _this5.write(value, buffer, offset, typeArg.type, value);else offset = _this5.write(value[typeArg.name], buffer, offset, typeArg.type, value);
    }, function (e) {
      if (typeArgs && typeArg && typeArg.name) addErrorField(e, typeArg.name);else addErrorField(e, "unknown");
      throw e;
    });
  });
  delete value[".."];
  return offset;
}

function sizeOfContainer(value, typeArgs, context) {
  var _this6 = this;

  value[".."] = context;
  var size = 0;
  typeArgs.forEach(function (typeArg) {
    tryCatch(function () {
      if (typeArg.anon) size += _this6.sizeOf(value, typeArg.type, value);else size += _this6.sizeOf(value[typeArg.name], typeArg.type, value);
    }, function (e) {
      if (typeArgs && typeArg && typeArg.name) addErrorField(e, typeArg.name);else addErrorField(e, "unknown");
      throw e;
    });
  });
  delete value[".."];
  return size;
}

function readCount(buffer, offset, typeArgs, rootNode) {
  return this.read(buffer, offset, typeArgs.type, rootNode);
}

function writeCount(value, buffer, offset, typeArgs, rootNode) {
  // Actually gets the required field, and writes its length. Value is unused.
  // TODO : a bit hackityhack.
  return this.write(getField(typeArgs.countFor, rootNode).length, buffer, offset, typeArgs.type, rootNode);
}

function sizeOfCount(value, typeArgs, rootNode) {
  // TODO : should I use value or getField().length ?
  return this.sizeOf(getField(typeArgs.countFor, rootNode).length, typeArgs.type, rootNode);
}
//# sourceMappingURL=../maps/datatypes/structures.js.map
