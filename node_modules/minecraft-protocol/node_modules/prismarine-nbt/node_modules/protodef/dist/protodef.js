'use strict';

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _Object$keys = require('babel-runtime/core-js/object/keys')['default'];

var _require = require('./utils');

var getFieldInfo = _require.getFieldInfo;
var tryCatch = _require.tryCatch;

var reduce = require('lodash.reduce');

function isFieldInfo(type) {
  return typeof type === "string" || Array.isArray(type) && typeof type[0] === "string" || type.type;
}

function findArgs(acc, v, k) {
  if (typeof v === "string" && v.charAt(0) === '$') acc.push({ "path": k, "val": v.substr(1) });else if (Array.isArray(v) || typeof v === "object") acc = acc.concat(reduce(v, findArgs, []).map(function (v) {
    return { "path": k + "." + v.path, "val": v.val };
  }));
  return acc;
}

function setField(path, val, into) {
  var c = path.split('.').reverse();
  while (c.length > 1) {
    into = into[c.pop()];
  }
  into[c.pop()] = val;
}

function extendType(functions, defaultTypeArgs) {
  var json = JSON.stringify(defaultTypeArgs);
  var argPos = reduce(defaultTypeArgs, findArgs, []);
  function produceArgs(typeArgs) {
    var args = JSON.parse(json);
    argPos.forEach(function (v) {
      setField(v.path, typeArgs[v.val], args);
    });
    return args;
  }
  return [function read(buffer, offset, typeArgs, context) {
    return functions[0].call(this, buffer, offset, produceArgs(typeArgs), context);
  }, function write(value, buffer, offset, typeArgs, context) {
    return functions[1].call(this, value, buffer, offset, produceArgs(typeArgs), context);
  }, function sizeOf(value, typeArgs, context) {
    if (typeof functions[2] === "function") return functions[2].call(this, value, produceArgs(typeArgs), context);else return functions[2];
  }];
}

var ProtoDef = (function () {
  function ProtoDef() {
    _classCallCheck(this, ProtoDef);

    this.types = {};

    this.addDefaultTypes();
  }

  _createClass(ProtoDef, [{
    key: 'addDefaultTypes',
    value: function addDefaultTypes() {
      this.addTypes(require("./datatypes/numeric"));
      this.addTypes(require("./datatypes/utils"));
      this.addTypes(require("./datatypes/structures"));
      this.addTypes(require("./datatypes/conditional"));
    }
  }, {
    key: 'addType',
    value: function addType(name, functions) {
      if (functions === "native") return;
      if (isFieldInfo(functions)) {
        var fieldInfo = getFieldInfo(functions);
        this.types[name] = extendType(this.types[fieldInfo.type], fieldInfo.typeArgs);
      } else this.types[name] = functions;
    }
  }, {
    key: 'addTypes',
    value: function addTypes(types) {
      var self = this;
      _Object$keys(types).forEach(function (name) {
        self.addType(name, types[name]);
      });
    }
  }, {
    key: 'read',
    value: function read(buffer, cursor, _fieldInfo, rootNodes) {
      var fieldInfo = getFieldInfo(_fieldInfo);
      var type = this.types[fieldInfo.type];
      if (!type) {
        return {
          error: new Error("missing data type: " + fieldInfo.type)
        };
      }
      var readResults = type[0].call(this, buffer, cursor, fieldInfo.typeArgs, rootNodes);
      if (readResults == null) {
        throw new Error("Reader returned null : " + JSON.stringify(fieldInfo));
      }
      if (readResults && readResults.error) return { error: readResults.error };
      return readResults;
    }
  }, {
    key: 'write',
    value: function write(value, buffer, offset, _fieldInfo, rootNode) {
      var fieldInfo = getFieldInfo(_fieldInfo);
      var type = this.types[fieldInfo.type];
      if (!type) {
        return {
          error: new Error("missing data type: " + fieldInfo.type)
        };
      }
      return type[1].call(this, value, buffer, offset, fieldInfo.typeArgs, rootNode);
    }
  }, {
    key: 'sizeOf',
    value: function sizeOf(value, _fieldInfo, rootNode) {
      var fieldInfo = getFieldInfo(_fieldInfo);
      var type = this.types[fieldInfo.type];
      if (!type) {
        throw new Error("missing data type: " + fieldInfo.type);
      }
      if (typeof type[2] === 'function') {
        return type[2].call(this, value, fieldInfo.typeArgs, rootNode);
      } else {
        return type[2];
      }
    }
  }, {
    key: 'createPacketBuffer',
    value: function createPacketBuffer(type, packet) {
      var _this = this;

      var length;
      tryCatch(function () {
        return length = _this.sizeOf(packet, type, {});
      }, function (e) {
        e.message = 'SizeOf error for ' + e.field + ' : ' + e.message;
        throw e;
      });
      var buffer = new Buffer(length);
      tryCatch(function () {
        return length = _this.write(packet, buffer, 0, type, {});
      }, function (e) {
        e.message = 'Write error for ' + e.field + ' : ' + e.message;
        throw e;
      });
      return buffer;
    }
  }, {
    key: 'parsePacketBuffer',
    value: function parsePacketBuffer(type, buffer) {
      var _this2 = this;

      var r;
      tryCatch(function () {
        return r = _this2.read(buffer, 0, type, {});
      }, function (e) {
        e.message = 'Read error for ' + e.field + ' : ' + e.message;
        throw e;
      });
      return {
        data: r.value,
        metadata: {
          size: r.size
        },
        buffer: buffer
      };
    }
  }]);

  return ProtoDef;
})();

module.exports = ProtoDef;
//# sourceMappingURL=maps/protodef.js.map
